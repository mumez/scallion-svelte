import { describe, it, expect, beforeEach } from 'vitest';
import PageService from '../PageService';
import type { PageContent } from '$lib/models/PageContent';

// This test uses the MSW mocks defined in src/lib/mocks/api.ts
// The MSW server is automatically started by setupTests.ts

describe('PageService Integration Tests', () => {
	let pageService: PageService;

	beforeEach(() => {
		pageService = new PageService('ume', 'index');
	});

	describe('getContent', () => {
		it('fetches existing page content successfully', async () => {
			const result = await pageService.getContent();

			expect(result).toMatchObject({
				name: 'index',
				wiki: 'ume',
				content: 'index content hello',
				updatedBy: 'ume@softumeya.com',
				isLocked: false
			});
			
			expect(result.id).toBeTruthy();
			expect(result.updatedAt).toBeTypeOf('number');
			expect(result.number).toBeTypeOf('number');
		});

		it('handles non-existent pages', async () => {
			const nonExistentPageService = new PageService('ume', 'nonexistent');
			
			const result = await nonExistentPageService.getContent();
			// Should return empty object for non-existent pages
			expect(result).toEqual({});
		});

		it('fetches different pages correctly', async () => {
			const test1PageService = new PageService('ume', 'test1');
			const result = await test1PageService.getContent();

			expect(result).toMatchObject({
				name: 'test1',
				wiki: 'ume',
				content: 'test content update',
				updatedBy: 'updater1'
			});
		});
	});

	describe('postContent', () => {
		it('creates new page successfully', async () => {
			const newPageContent: PageContent = {
				name: 'newpage',
				content: '# New Page\n\nThis is new content.',
				wiki: 'ume',
				updatedBy: 'testuser@example.com',
				title: 'New Page Title',
				// Required fields for the API
				id: '', // Will be generated by server
				bookId: '4mmw6ztlrzrrr1nv9hszjk3vy',
				number: 0, // Will be set by server
				updatedAt: 0, // Will be set by server
				isLocked: false
			};

			const result = await pageService.postContent(newPageContent);

			expect(result).toMatchObject({
				name: 'newpage',
				content: '# New Page\n\nThis is new content.',
				wiki: 'ume',
				updatedBy: 'testuser@example.com',
				title: 'New Page Title',
				isLocked: false
			});

			// Server should have generated these fields
			expect(result.id).toBeTruthy();
			expect(result.id).toMatch(/^new-\d+$/);
			expect(result.updatedAt).toBeTypeOf('number');
			expect(result.number).toBeGreaterThan(0);
			expect(result.bookId).toBe('4mmw6ztlrzrrr1nv9hszjk3vy');
		});
	});

	describe('putContent', () => {
		it('updates existing page successfully', async () => {
			// First get the existing page
			const existingPage = await pageService.getContent();
			
			// Update the content
			const updatedContent: PageContent = {
				...existingPage,
				content: '# Updated Content\n\nThis content has been updated.',
				title: 'Updated Title',
				updatedBy: 'updater@example.com'
			};

			const result = await pageService.putContent(updatedContent);

			expect(result).toMatchObject({
				id: existingPage.id,
				name: 'index',
				content: '# Updated Content\n\nThis content has been updated.',
				title: 'Updated Title',
				wiki: 'ume',
				updatedBy: 'updater@example.com'
			});

			// Version number should be incremented
			expect(result.number).toBe(existingPage.number + 1);
			
			// Updated timestamp should be newer
			expect(result.updatedAt).toBeGreaterThan(existingPage.updatedAt);
		});

		it('handles updates to non-existent pages', async () => {
			const nonExistentContent: PageContent = {
				id: 'non-existent-id',
				name: 'nonexistent',
				content: 'This should fail',
				wiki: 'ume',
				bookId: 'test-book-id',
				number: 1,
				updatedAt: Date.now(),
				updatedBy: 'testuser@example.com',
				isLocked: false
			};

			const result = await pageService.putContent(nonExistentContent);
			// Should return empty object for failed updates
			expect(result).toEqual({});
		});
	});

	describe('API error handling', () => {
		it('handles network errors gracefully', async () => {
			// Create a service that will hit a non-mocked endpoint
			const errorService = new PageService('invalid-wiki', 'invalid-page');
			
			const result = await errorService.getContent();
			// Should return empty object for network errors
			expect(result).toEqual({});
		});
	});

	describe('JWT token handling', () => {
		it('includes JWT token in authenticated requests', async () => {
			// Mock JWT token in localStorage or wherever it's stored
			// This test verifies that the token is properly sent with requests
			
			const newContent: PageContent = {
				name: 'auth-test',
				content: 'Content requiring auth',
				wiki: 'ume',
				updatedBy: 'authenticated@example.com',
				title: 'Auth Test',
				id: '',
				bookId: '4mmw6ztlrzrrr1nv9hszjk3vy',
				number: 0,
				updatedAt: 0,
				isLocked: false
			};

			// This should work because MSW mocks don't require actual auth
			// In a real scenario, you'd mock the JWT token storage
			const result = await pageService.postContent(newContent);
			expect(result).toBeTruthy();
		});
	});
});